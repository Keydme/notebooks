# å¥‡æ€ªçš„è¯
[confidence_intervalè¯¦è§£](https://www.shuxuele.com/data/confidence-interval.html)
ç”µè„‘ä¸Šçš„esimğŸ¤£
é¾™æ ¼åº“å¡”æ³•
è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ[](https://mp.weixin.qq.com/s?__biz=MjM5NjYwNzM1Ng==&mid=2651678044&idx=2&sn=1ba41f911b5a0b362263e95ef1d289e3&chksm=bd1f614f8a68e85917815cac252d9eef6d1c069ddcc0e144f3e9fbe8074cb6d9be42b9bf28a4&scene=27)
å¼ é‡
pythonå¾®åˆ†æ–¹ç¨‹æ±‚è§£

åŠå³°å…¨å®½ï¼ˆå­—é¢æ„æ€ï¼‰

å…‰æ³¢å¯¼ï¼Ÿï¼Ÿ

è‡ªåˆ¶ç›–é©è®¡æ•°å™¨[](https://zhuanlan.zhihu.com/p/503370079?utm_id=0)
[Pngæ–‡ä»¶ç»“æ„](https://blog.csdn.net/BeatriceDluberry/article/details/123532416)
# äºŒåˆ†æ³•çš„å›ºå®šä¼˜åŒ–ç‡
### Question 1 [20 marks]
```python
while b-a > eps:
    m = (b+a)/2
    if f(a)*f(m) < 0:
        b = m
    else:
        a = m
return a
```

Consider the version of the algorithm implemented above. Implement a functionÂ `bisection_iterations(a,b,eps)`Â that returns the number of iterations that the algorithm will perform.Â **Note: you do not need to run the algorithm; analyse the implementation and find a formula for the number of iterations.**
äºŒåˆ†æ³•é¢˜è§£ï¼š
- ç”±äºè·³å‡ºå¾ªç¯çš„æ˜¯a,bçš„é—´è·ï¼Œåœ¨äºŒåˆ†æ³•ä¸­ï¼Œa,bçš„é—´è·å–å†³äºå…¶æ·±åº¦
- å¦‚$1.e-8>\frac{1}{2^{3
- 0}}$

# è¿˜ç®—åˆç†çš„äºŒåˆ†æ³•æ€»ç»“
```python
#å…¨ä»£ç 
def find(a,b,f,d = 0,lr = []):
Â  Â  m = (a+b)/2Â  Â  #print(a,b,d,lr,round(f(a)*f(b),3))
Â  Â  if f(a)*f(b)<=0:
Â  Â  Â  Â  return a,b,d,lr
Â  Â  elif abs(a-b)<eps:
Â  Â  Â  Â  return ()
Â  Â  elif d>8:
Â  Â  Â  Â  return ()
Â  Â  else:
Â  Â  Â  Â  return find(a,m,f,d+1,lr+[-1])+find(m,b,f,d+1,lr+[1])
# find(a,b,ff)
# print(find(a,b,ff))
```
find å‡½æ•°ç”¨äºç®€ç­”ç¡®å®šæ ¹å€¼åŒºé—´ï¼Œåªè¦ä¸è¦å‡ºç°åœ¨æå°çš„åŒºé—´å†…åˆä¸‹é™åˆä¸Šå‡å°±åŸºæœ¬ä¸ä¼šæ­»
åœ¨d<=8çš„æ—¶å€™ï¼Œç²¾åº¦å¤§æ¦‚åœ¨$/frac{b-a}{2^9}$å·¦å³å¤§æ¦‚æ˜¯0.01*ï¼ˆb-aï¼‰,soï¼Œå½“åŒºé—´è¿æ°”ä¸å¥½æ—¶ï¼Œæ ¹åŒºæœ‰å°æ¦‚ç‡è¢«å¿½ç•¥ã€‚
++å¦‚æœæœ‰ä¸‰æ ¹åŒºé—´ï¼Œä¹Ÿæœ‰æ¦‚ç‡ä¼šè·³è¿‡å…¶ä¸­çš„ä¸¤ä¸ªæ ¹æ¤
```python
def bs(f,x):
# äºŒåˆ†æ³•æ±‚æ ¹
Â  Â  a,b = x
Â  Â  a,b = find(a,b,f)[:2]
Â  Â  m = (a+b)/2
Â  Â  if f(a)*f(m)<=0:
Â  Â  Â  Â  b=m
Â  Â  else:
Â  Â  Â  Â  a=m
Â  Â  return a,b
```
åŸºç¡€æ±‚æ ¹ï¼Œè¯´å®è¯å€’æ˜¯æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯åœ¨åŒæ ¹åŒºæ—¶ä»–å°±æœ‰ç‚¹éš¾ä»¥èƒœä»»ï¼Œå¿…é¡»è¦åˆ›é€ ä¸€ä¸ª$f(a)*f(b)<0,[a,b]$è¿™ä¹Ÿå°±æ˜¯findå‡½æ•°å­˜åœ¨çš„æ„ä¹‰ï¼Œfindä»…åœ¨åŒºåŸŸå†…æ’é’ˆå¹¶è¿”å›å¯è§£åŒºå·¦å³
```python
def fpb(x0,f,bs,eps):
Â  Â  while x[1]-x[0]>eps:
Â  Â  Â  Â  x0 = bs(f,x0)
#Â  Â  print(x0,(x0[0]-x0[1])/2)
Â  Â  return (x[1]+x[0])/2
```
æŒ‡å®šç²¾åº¦å¹¶è¿”å›
æ³¨æ„ï¼Œæœ¬äºŒåˆ†ä»…å®ç°äº†æœ€è¿‘çš„è§£çš„è¿”å›ã€‚
[å†…é™„ä¸€ä¸ªå¤šæ ¹äºŒåˆ†æ³•å®ç°ï¼ˆå¤§ä½¬ï¼Ÿï¼‰](https://zhuanlan.zhihu.com/p/497806698?utm_id=0)
# numpy
#numpy
np.floorï¼Œinté»˜è®¤æœ‰ä½æ•°ä¸Šçº¿ï¼Œ17ä½æœ‰æ•ˆæ•°å­—ï¼Ÿ
å¯èƒ½æ˜¯python floatçš„ä½æ•°ä¸Šçº¿ï¼Ÿ

np.linalg.norm èŒƒæ•°ï¼Œ1èŒƒæ•°ä¸ºdistanceï¼Œ2èŒƒæ•°ï¼ˆé»˜è®¤ï¼‰ä¸ºå‘é‡é•¿åº¦
# ç¥å¥‡çš„fixed point
å…ˆæ”¾ä¸ªé“¾æ¥[# Python å®ç°æ•°å€¼åˆ†æäºŒåˆ†æ³•ï¼Œç‰›é¡¿æ³•ï¼Œä¸åŠ¨ç‚¹æ³•è§£æ–¹ç¨‹](https://blog.csdn.net/wwxy1995/article/details/82757894)
contraction mapping
lipschitzæ¡ä»¶
